% auROC calcium analysis
% ZZ 05/19/21
% ROC and single unit classifier
% as implemented in Kingsbury...Hong (2020) Neuron

%% SETUP
% LOAD INTO WORKSPACE:  
% 1) sig = signal matrix (sigfn, dff, or spkfn)[ref paper uses dff]
% NB: must load into workspace with same 'sig' 0
% 2) frtslusig = frame lookup, generated by  'generatefrlu' func
% 3) 'Behavior' struct from behdepot

% NB1: sig length MUST match eventmat length (see align data section)
% NB2: eventmat and sig MUST be in the same timeframe as each other (ie
% eventmat(1) is the same time as sig(1), eventmat(100) == sig(100), etc).
% (see align data section)

% load Behavior, Behavior_Filter
freeze_vec = Behavior.Freezing.Vector;  % load freezing vector
freeze_vec = freeze_vec(2:end);  %drop first frame
csp_vec = Behavior.Temporal.csp.Vector;
csp_vec = csp_vec(2:end);
csm_vec = Behavior.Temporal.csm.Vector;
csm_vec = csm_vec(2:end);
%csp_frz_vec = Behavior.Temporal.csp.Freezing.BehInEventVector;
%csp_frz_vec = csp_frz_vec(2:end);
%csm_frz_vec = Behavior.Temporal.csm.Freezing.BehInEventVector;
%csm_frz_vec = csm_frz_vec(2:end);
%us_vec = Behavior_Filter.Temporal.us.EventVector;
%us_vec = us_vec(2:end);


event_vec_names = {'freeze', 'CSp', 'CSm'};
event_vectors = [freeze_vec; csp_vec; csm_vec];

save_dir = uigetdir([],'Select directory to save output')
% use cutoff to trim data if needed (based on behavior vector)
% if want to use all, leave cutoff empty
cutoff = [];

if isempty(cutoff)
    cutoff = length(event_vectors);
end


% eventmat = eventvec(1:cutoff);
% 
% % take only the calcium frames aligned to the behavior
sig = sig(:,frtslu(1:cutoff,3));
%% zscore data

zsig = zscore(sig, 0, 2);  % zscore data to normalize
nn = size(zsig,1);  % Number of Neurons
nf = size(zsig,2);  % Number of Frames

%% generate ROC using matlab func perfcurve
%only take 100 samples to prevent: 1) step functions in ROC curve; 2)
%different sized ROC vectors curves
for i_event = 1:length(event_vec_names)
    disp(['now doing ' event_vec_names{i_event}])
    eventmat = event_vectors(i_event,:);
    
    if sum(eventmat) ~= 0  % check to see if there's anything to align to, skip if not 
        % load event vec
        roc = zeros(100,2,nn);
        auc_n = zeros(1,nn);
        x = [];
        y = [];

        for i_n = 1:nn
            [x,y,~,AUC] = perfcurve(eventmat,zsig(i_n,:),1);    
            x_samples = x(1:length(x)/100:end);
            y_samples = y(1:length(y)/100:end);
            roc(:,:,i_n) = [x_samples,y_samples];
            auc_n(i_n) = AUC;
        end

        %% plot ROCs to take a look at each one. Comment out if no plot desired
        %  for zz = 1:nn
        %      plot(roc(:,1,zz), roc(:,2,zz));
        %      pause;
        %  end

        %% generate null distribution of auROCs 
        % circularly shuffle event timing and recalculating ROCs
        % this takes a while (note the parfor loop)

        perm = 1000;
        auc_perm = zeros(nn,perm);
        % turn off annoying warning
        warning('off','MATLAB:colon:nonIntegerIndex');

        disp('counter broken with parallel computing and 6/3/2022 zach is too lazy to fix it')
        disp('¯\_(ツ)_/¯ ')
        parfor i_perm = 1:perm
            i_start = randi([2,length(eventmat)],1);
            eventmat_shuf = horzcat(eventmat(i_start:end), eventmat(1:i_start-1));

            for i_n = 1:nn
              [~,~,~,AUC] = perfcurve(eventmat_shuf,zsig(i_n,:),1);
              auc_perm(i_n,i_perm) = AUC;
            end

            % doesn't work with parfor loop
            if rem(i_perm,50)==0
                per_done = i_perm/perm*100;
                disp([num2str(per_done) '% done']);
            end
        end
        % 

        %% compute percentile of real auROCs
        centile = zeros(nn,1);
        for i_n = 1:nn
            nless = sum(auc_perm(i_n,:) < auc_n(i_n));
            nequal = sum(auc_perm(i_n,:) == auc_n(i_n));
            centile(i_n) = 100 * (nless + 0.5*nequal) / size(auc_perm,2);
        end

        n_suppressed = find(centile <= 2.5);
        n_excited = find(centile >= 97.5);

        %% plot sig ROCs to take a look at each one. 
        % Comment out if no plot desired
    %     figure;
    %     for zz = 1:length(n_excited)
    %          plot(roc(:,1,n_excited(zz)), roc(:,2,n_excited(zz)));
    %          title(['excited cell ID #' num2str(n_excited(zz))]);
    %          legend(['AUC = ' num2str(auc_n(n_excited(zz)))]);
    %          ylabel('True Positive Rate')
    %          xlabel('False Positive Rate')
    %          pause;
    %     end
    % 
    %     for zz = 1:length(n_suppressed)
    %          plot(roc(:,1,n_suppressed(zz)), roc(:,2,n_suppressed(zz)));
    %          title(['suppressed cell ID #' num2str(n_suppressed(zz))]);
    %          legend(['AUC = ' num2str(auc_n(n_suppressed(zz)))]);
    %          ylabel('True Positive Rate')
    %          xlabel('False Positive Rate')
    %          pause;
    %     end

        %% visualize histogram of real auROC (red line) vs null distribution
        %% Comment out if desired
        % nsig = length(n_suppressed) + length(n_excited);
        % sigcells = [n_excited; n_suppressed];
        % for zz = 1:nsig
        %     histogram(auc_perm(sigcells(zz),:),50);
        %     xline(auc_n(sigcells(zz)),'r');
        %     title(['histogram of shuffled auROCs - cell ID #' num2str(sigcells(zz))]);
        %     pause;
        %     clf;
        % end

        out.(event_vec_names{i_event}).event_vec = eventmat;
        out.(event_vec_names{i_event}).n_excited = n_excited;
        out.(event_vec_names{i_event}).n_suppressed = n_suppressed;
        out.(event_vec_names{i_event}).roc = roc;
        out.(event_vec_names{i_event}).auc_neurons = auc_n;
    else
        disp('nothing in this event vector. skipping');
    end

    %% make table to arrange it by neuron view
    % Extract fields from the struct
fields = fieldnames(out);

% Determine the number of neurons from auc_neurons
numNeurons = size(out.(fields{1}).auc_neurons, 2);

% Preallocate a cell array for the table data
tableData = cell(numNeurons, 2*length(fields));
neuronIndices = (1:numNeurons)';

% Loop over fields and extract n_excited and n_suppressed data
for i = 1:length(fields)
    currField = fields{i};
    
    excitedIndices = out.(currField).n_excited;
    suppressedIndices = out.(currField).n_suppressed;
    
    % Create logical arrays to indicate if a neuron is excited or suppressed
    isExcited = ismember(neuronIndices, excitedIndices);
    isSuppressed = ismember(neuronIndices, suppressedIndices);
    
    % Store the indices or empty cell
    tableData(:, 2*i-1) = cellfun(@(x) x, num2cell(isExcited .* neuronIndices), 'UniformOutput', false);
    tableData(:, 2*i) = cellfun(@(x) x, num2cell(isSuppressed .* neuronIndices), 'UniformOutput', false);
end

% Replace zeros with empty cells for cleaner appearance
tableData(cellfun(@(x) x == 0, tableData)) = {[]};

% Create table column names
columnNames = cell(1, 2*length(fields));
for i = 1:length(fields)
    columnNames{2*i-1} = [fields{i} '_excited'];
    columnNames{2*i} = [fields{i} '_suppressed'];
end

% Create table
neuronTable = array2table(tableData, 'VariableNames', columnNames);

%% make a table to arrange it by event view
% Extract fields from the struct
fields = fieldnames(out);

% Determine the number of neurons from auc_neurons
numNeurons = size(out.(fields{1}).auc_neurons, 2);

neuronIndices = (1:numNeurons)';

% Preallocate cell arrays for the excited and suppressed data
excitedData = cell(length(fields), 1);
suppressedData = cell(length(fields), 1);

% Loop over fields and extract n_excited and n_suppressed data
for i = 1:length(fields)
    currField = fields{i};
    
    excitedData{i} = out.(currField).n_excited;
    suppressedData{i} = out.(currField).n_suppressed;
end

% Create table
eventTable = table(excitedData, suppressedData, 'RowNames', fields, 'VariableNames', {'Excited', 'Suppressed'});

end

%% save
save([save_dir '\ca_roc_output.mat'], 'out', 'sig', 'csp_vec', 'csm_vec', 'freeze_vec','neuronTable','eventTable');