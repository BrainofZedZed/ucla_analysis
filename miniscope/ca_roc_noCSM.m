% auROC calcium analysis
% ZZ 05/19/21
% ROC and single unit classifier
% as implemented in Kingsbury...Hong (2020) Neuron

%% SETUP
% LOAD INTO WORKSPACE:  
% 1) sig = signal matrix (sigfn, dff, or spkfn)[ref paper uses dff]
% NB: must load into workspace with same 'sig' 
% 2) frtslu = frame lookup, generated by  'generatefrlu' func
% 3) 'Behavior' struct from behdepot

% NB1: sig length MUST match eventmat length (see align data section)
% NB2: eventmat and sig MUST be in the same timeframe as each other (ie
% eventmat(1) is the same time as sig(1), eventmat(100) == sig(100), etc).
% (see align data section)

%% create behavior vectors
freeze_vec = Behavior.Freezing.Vector;  % load freezing vector
%freeze_vec = freeze_vec(2:end);  %drop first frame
csp_vec = Behavior.Temporal.csp.Vector;
%csp_vec = csp_vec(2:end);

%create tone onset vector
% Initialize the new vector with zeros
csp_onset_vec = zeros(size(csp_vec));

% Initialize the counter for consecutive ones
count = 0;
max_count=75; % equals 3s in miniscope frames
% Loop through the original vector
for i = 1:length(csp_vec)
    if csp_vec(i) == 1
        % Increment the count if the current element is 1
        count = count + 1;
        
        % Set the element in the new vector to 1 if count is within the limit
        if count <= max_count
            csp_onset_vec(i) = 1;
        end
    else
        % Reset the count if the current element is not 1
        count = 0;
    end
end

csp_offset_vec = zeros(size(csp_vec));
count = 0;
offset_length = 75;
% Loop through the original vector to find 1 to 0 transitions
for i = 1:length(csp_vec) - 1
    if csp_vec(i) == 1 && csp_vec(i + 1) == 0
        % Calculate the end index for the offset
        end_index = min(i + offset_length, length(csp_vec));
        
        % Set the offset to 1 for the specified length after the transition
        csp_offset_vec(i + 1:end_index) = 1;
    end
end

nontone_freeze_vec = freeze_vec - csp_vec;
nontone_freeze_vec(nontone_freeze_vec<0) = 0;

if isfield(Behavior.Temporal,'us')
    us_flag = 1;
    us_vec = Behavior.Temporal.us.Vector;
    us_mat = vec2mat(us_vec);
    us_mat(:,2) = us_mat(:,2)+50;
    us_vec = mat2vec(us_mat,length(us_vec));
    
    post_us_mat = us_mat;
    post_us_mat(:,1) = post_us_mat(:,2);
    post_us_mat(:,2) = post_us_mat(:,2)+125;
    post_us_vec = mat2vec(post_us_mat,length(us_vec));

else
    us_flag = 0;
    us_vec = zeros(size(csp_vec));
    post_us_vec = us_vec;
end

% check if US is present and load event vectors into matrix to loop
% event vector names must match the index of the vector
if us_flag
    event_vec_names = {'freeze', 'nontone_freeze','CSp', 'CSp_onset','CSp_offset', 'shock', 'post_shock'};
    event_vectors = [freeze_vec; nontone_freeze_vec; csp_vec; csp_onset_vec; csp_offset_vec; us_vec; post_us_vec];
else
    event_vec_names = {'freeze', 'nontone_freeze','CSp', 'CSp_onset','CSp_offset'};
    event_vectors = [freeze_vec; nontone_freeze_vec; csp_vec; csp_onset_vec; csp_offset_vec];
end

save_dir = pwd;

%% align data
% add cutoff to data if desired
cutoff = 0;

if cutoff > 0
    sig = sig(:,frtslu(1:cutoff,3));
    event_vectors = event_vectors(:,1:cutoff);
else
    sig = sig(:,frtslu(:,3));
    event_vectors = event_vectors(:,1:size(sig,2));
end
%% zscore data

zsig = zscore(sig, 0, 2);  % zscore data to normalize
nn = size(zsig,1);  % Number of Neurons
nf = size(zsig,2);  % Number of Frames

%% generate ROC using matlab func perfcurve
%only take 100 samples to prevent: 1) step functions in ROC curve; 2)
%different sized ROC vectors curves
for i_event = 1:length(event_vec_names)
    disp(['now doing ' event_vec_names{i_event}])
    eventmat = event_vectors(i_event,:);
    
    if sum(eventmat) ~= 0  % check to see if there's anything to align to, skip if not 
        % load event vec
        roc = zeros(100,2,nn);
        auc_n = zeros(1,nn);
        x = [];
        y = [];

        for i_n = 1:nn
            [x,y,~,AUC] = perfcurve(eventmat,zsig(i_n,:),1);    
            x_samples = x(1:length(x)/100:end);
            y_samples = y(1:length(y)/100:end);
            roc(:,:,i_n) = [x_samples,y_samples];
            auc_n(i_n) = AUC;
        end

        %% plot ROCs to take a look at each one. Comment out if no plot desired
        %  for zz = 1:nn
        %      plot(roc(:,1,zz), roc(:,2,zz));
        %      pause;
        %  end

        %% generate null distribution of auROCs 
        % circularly shuffle event timing and recalculating ROCs
        % this takes a while (note the parfor loop)

        perm = 1000;
        auc_perm = zeros(nn,perm);
        % turn off annoying warning
        warning('off','MATLAB:colon:nonIntegerIndex');

        disp('counter broken with parallel computing and 6/3/2022 zach is too lazy to fix it')
        disp('¯\_(ツ)_/¯ ')
        parfor i_perm = 1:perm
            i_start = randi([2,length(eventmat)],1);
            eventmat_shuf = horzcat(eventmat(i_start:end), eventmat(1:i_start-1));

            for i_n = 1:nn
              [~,~,~,AUC] = perfcurve(eventmat_shuf,zsig(i_n,:),1);
              auc_perm(i_n,i_perm) = AUC;
            end

            % doesn't work with parfor loop
            if rem(i_perm,50)==0
                per_done = i_perm/perm*100;
                disp([num2str(per_done) '% done']);
            end
        end
        % 

        %% compute percentile of real auROCs
        centile = zeros(nn,1);
        for i_n = 1:nn
            nless = sum(auc_perm(i_n,:) < auc_n(i_n));
            nequal = sum(auc_perm(i_n,:) == auc_n(i_n));
            centile(i_n) = 100 * (nless + 0.5*nequal) / size(auc_perm,2);
        end

        n_suppressed = find(centile <= 2.5);
        n_excited = find(centile >= 97.5);

        %% plot sig ROCs to take a look at each one. 
        % Comment out if no plot desired
    %     figure;
    %     for zz = 1:length(n_excited)
    %          plot(roc(:,1,n_excited(zz)), roc(:,2,n_excited(zz)));
    %          title(['excited cell ID #' num2str(n_excited(zz))]);
    %          legend(['AUC = ' num2str(auc_n(n_excited(zz)))]);
    %          ylabel('True Positive Rate')
    %          xlabel('False Positive Rate')
    %          pause;
    %     end
    % 
    %     for zz = 1:length(n_suppressed)
    %          plot(roc(:,1,n_suppressed(zz)), roc(:,2,n_suppressed(zz)));
    %          title(['suppressed cell ID #' num2str(n_suppressed(zz))]);
    %          legend(['AUC = ' num2str(auc_n(n_suppressed(zz)))]);
    %          ylabel('True Positive Rate')
    %          xlabel('False Positive Rate')
    %          pause;
    %     end

        %% visualize histogram of real auROC (red line) vs null distribution
        %% Comment out if desired
        % nsig = length(n_suppressed) + length(n_excited);
        % sigcells = [n_excited; n_suppressed];
        % for zz = 1:nsig
        %     histogram(auc_perm(sigcells(zz),:),50);
        %     xline(auc_n(sigcells(zz)),'r');
        %     title(['histogram of shuffled auROCs - cell ID #' num2str(sigcells(zz))]);
        %     pause;
        %     clf;
        % end

        out.(event_vec_names{i_event}).event_vec = eventmat;
        out.(event_vec_names{i_event}).n_excited = n_excited;
        out.(event_vec_names{i_event}).n_suppressed = n_suppressed;
        out.(event_vec_names{i_event}).roc = roc;
        out.(event_vec_names{i_event}).auc_neurons = auc_n;
    else
        disp('nothing in this event vector. skipping');
    end


end

%% save
if us_flag
    save([save_dir '/ca_roc_output.mat'], 'out', 'sig', 'event_vec_names','event_vectors','csp_vec', 'csp_onset_vec','csp_offset_vec','freeze_vec', 'nontone_freeze_vec', 'us_vec','post_us_vec', 'cutoff');
else
    save([save_dir '/ca_roc_output.mat'], 'out', 'sig', 'event_vec_names','event_vectors','csp_vec', 'csp_onset_vec','csp_offset_vec','freeze_vec', 'nontone_freeze_vec', 'cutoff');
end